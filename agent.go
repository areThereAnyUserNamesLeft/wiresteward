package main

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

const (
	defaultTokenFileLoc = "/var/lib/wiresteward/token"
)

// Agent is the wirestward client instance that manages a set of network devices
// based on configuration generated by remote wiresteward servers.
type Agent struct {
	deviceManagers []*DeviceManager
	oa             *oauthTokenHandler
}

// NewAgent creates an Agent from an AgentConfig. It generates a DeviceManager
// per device specified in the configuration, sets up and starts the associated
// resources.
func NewAgent(cfg *agentConfig) *Agent {
	agent := &Agent{}
	for _, dev := range cfg.Devices {
		urls := []string{}
		for _, peer := range dev.Peers {
			urls = append(urls, peer.URL)
		}
		dm := newDeviceManager(dev.Name, dev.MTU, urls)
		if err := dm.Run(); err != nil {
			logger.Error.Printf(
				"Error starting device `%s`: %v",
				dm.Name(),
				err,
			)
			continue
		}
		agent.deviceManagers = append(agent.deviceManagers, dm)
	}
	tokenDir := filepath.Dir(defaultTokenFileLoc)
	err := os.MkdirAll(tokenDir, 0755)
	if err != nil {
		logger.Error.Printf("Unable to create directory=%s", tokenDir)
	}
	agent.oa = newOAuthTokenHandler(
		cfg.Oidc.AuthURL,
		cfg.Oidc.TokenURL,
		cfg.Oidc.ClientID,
		defaultTokenFileLoc,
	)
	return agent
}

// ListenAndServe sets up and starts an http server on localhost, to allow for
// the OAuth2 exchange and token renewal.
func (a *Agent) ListenAndServe() {
	http.HandleFunc("/oauth2/callback", a.callbackHandler)
	http.HandleFunc("/", a.mainHandler)

	logger.Info.Println("Starting agent at localhost:7773")

	token, err := a.oa.getTokenFromFile()
	if err != nil || token.AccessToken == "" || token.Expiry.Before(time.Now()) {
		logger.Error.Println("cannot get a valid cached token, you need to authenticate")
	} else {
		a.renewAllLeases(token.AccessToken)
	}

	// Start agent at a high obscure port. That port is hardcoded as oauth
	// server needs to allow redirections to localhost:7773/oauth2/callback
	// 7773 is chosen by looking wiresteward initials hex on ascii table
	// (w = 0x77 and s = 0x73)
	if err := http.ListenAndServe("127.0.0.1:7773", nil); err != nil {
		logger.Error.Fatal(err)
	}
}

// Stop calls the Stop method on all DeviceManager instances that this Agent
// controls.
func (a *Agent) Stop() {
	for _, dm := range a.deviceManagers {
		dm.Stop()
	}
}

func (a *Agent) renewAllLeases(token string) {
	logger.Info.Println("Running renew leases loop..")
	for _, dm := range a.deviceManagers {
		if err := dm.RenewLeases(token); err != nil {
			logger.Error.Printf(
				"Failed to renew leases for device `%s`: %v",
				dm.Name(),
				err,
			)
		}
	}
}

func (a *Agent) callbackHandler(w http.ResponseWriter, r *http.Request) {
	token, err := a.oa.ExchangeToken(r.FormValue("code"))
	if err != nil {
		fmt.Fprintf(
			w,
			"error fetching token from web: %v",
			err,
		)
		return
	}
	a.renewAllLeases(token.AccessToken)
	fmt.Fprintf(w, "Auth is now complete and agent is running! You can close this window")
}

func (a *Agent) mainHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		w.WriteHeader(http.StatusNotFound)
		return
	}

	token, err := a.oa.getTokenFromFile()
	if err != nil || token.AccessToken == "" || token.Expiry.Before(time.Now()) {
		logger.Error.Println(
			"cannot get a valid cached token, need a new one")
		// Get a url for the token challenge and redirect there
		url, err := a.oa.prepareTokenWebChalenge()
		if err != nil {
			fmt.Fprintf(
				w,
				"error creating web url to get token: %v",
				err,
			)
			return
		}
		http.Redirect(w, r, url, 302)
		return
	}
	a.renewAllLeases(token.AccessToken)
	fmt.Fprintf(w, "Agent refreshed and running! You can close this window now")
}
